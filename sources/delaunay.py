# -*- coding: utf-8 -*-
"""
Automatically generated by Colab.
"""
import numpy
import copy as cp
import random as rd
from queue import Queue

import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Circle
import seaborn as sns
sns.set_theme(style="darkgrid")

from .utils import Point
from .utils import SMALLER, EQUAL, LARGER
from .utils import orientation, inBetween, circumcircle

from .draw import drawPoint, drawSegment, drawTriangle

from .brio import Brio

class DelaunayTriangulation:
  """
  This is an object oriented implementation of Boywer-Watson
  algorithm coupled with BRIO to avoid a spatial data structure.
  """
  def __init__(self, tds):
    self.__tds = tds()

    # initialize bounding box
    self.__min = Point(0.0, 0.0)
    self.__max = Point(0.0, 0.0)

    # initialize canvas
    self.__fig, self.__ax = plt.subplots()
    self.__ax.set_aspect('equal')
    plt.close(self.__fig)

  # add first three non-collinear points
  def __insert_first_three(self, points):
    self.__tds.addVertex()
    self.__tds.addVertex()
    self.__tds.addVertex()

    p0 = points[0]
    p1 = points[1]
    # find p3 such that (p1,p2,p3) has positive orientation
    i = 2
    found = False
    while i < points.size:
      p2 = points[i]
      if orientation(p0, p1, p2) > 0:
        found = True
        break
      i = i + 1

    if not found:
      p0 = points[1]
      p1 = points[0]
      # find p3 such that (p1,p2,p3) has positive orientation
      i = 2
      while i < points.size:
        p2 = points[i]
        if orientation(p0, p1, p2) > 0:
          found = True
          break
        i = i + 1

    assert found == True

    if i != 2: # the third point is not at the third position, so fix it
      points[2], points[i] = points[i], points[2]

    # add faces (finite and infinite)
    self.__tds.addFace(1,2,3)
    self.__tds.addFace(0,2,1)
    self.__tds.addFace(0,3,2)
    self.__tds.addFace(0,1,3)

    # set points
    self.__tds._vertices[1].setPoint(p0)
    self.__tds._vertices[2].setPoint(p1)
    self.__tds._vertices[3].setPoint(p2)

  def __inConflict(self, p: Point, v0: int, v1: int, v2: int):
    if self.__tds.isInfinite(v0, v1, v2):
      # sort vertices to get (v0, v1, v2 = 0), i.e., infinite at last
      face = [v0,v1,v2]
      i  = face.index(0)
      v0 = face[(i+1)%3]
      v1 = face[(i+2)%3]

      v0 = self.__tds._vertices[v0]
      v1 = self.__tds._vertices[v1]

      p0 = v0.point
      p1 = v1.point
      
      orient = orientation(p0, p1, p)

      if orient > 0: # p is outside convex hull
        return True

      if orient == 0:  # in this case, only inside edge implies conflict
        return inBetween(p0, p1, p)

    else: # in case of finite face, proceed as always
      # compute incircle test
      v0 = self.__tds._vertices[v0]
      v1 = self.__tds._vertices[v1]
      v2 = self.__tds._vertices[v2]
      
      p0 = v0.point
      p1 = v1.point
      p2 = v2.point

      orient = orientation(p0, p1, p2, p)

      if orient >= 0:
        return True
      else:
        return False

  def __findFirst(self, p, hint):
    if hint == 0: # infinite vertex, find oposite face, which must be finite
      link = self.__tds._vertices[hint]._links[0]
      hint = self.__tds.findUp(link[1], link[0])

    print("NEW HINT: ", hint)

    status = None
    found = False
    print("  >>> findFirst:")
    while not found:
      print("  analyzing face (%d,%d,%d)" % (hint[0], hint[1], hint[2]))
      v0 = self.__tds._vertices[hint[0]]
      v1 = self.__tds._vertices[hint[1]]
      v2 = self.__tds._vertices[hint[2]]
      
      p0 = v0.point
      p1 = v1.point
      p2 = v2.point
      print("    > p0: ", p0.coords)
      print("    > p1: ", p1.coords)
      print("    > p2: ", p2.coords)

      print("    Computing first predicate")
      e0 = orientation(p0, p1, p) + 1
      print("    Computing second predicate")
      e1 = orientation(p1, p2, p) + 1
      print("    Computing third predicate")
      e2 = orientation(p2, p0, p) + 1

      mask = int(e2*9 + e1*3 + e0)
      
      if mask in [11, 20, 19]: # walk to v0 opposite vertex
        hint = self.__tds.findUp(hint[2], hint[1])
      elif mask in [5, 7, 8]: # walk to v1 opposite vertex
        hint = self.__tds.findUp(hint[0], hint[2])
      elif mask in [15, 21, 24]: # walk to v2 opposite vertex
        hint = self.__tds.findUp(hint[1], hint[2])
      elif mask == 2: # walk to v0 or v1 opposite vertex
        edge = rd.choice([[hint[2],hint[1]],[hint[0],hint[2]]])
        hint = self.__tds.findUp(edge[0], edge[1])
      elif mask == 6: # walk to v1 or v2 opposite vertex
        edge = rd.choice([[hint[0],hint[2]],[hint[1],hint[0]]])
        hint = self.__tds.findUp(edge[0], edge[1])
      elif mask == 18: # walk to v2 or v0 opposite vertex
        edge = rd.choice([[hint[1],hint[0]],[hint[2],hint[1]]])
        hint = self.__tds.findUp(edge[0], edge[1])
      elif mask == 16: # found at vertex v0
        found = True
      elif mask == 22: # found at vertex v1
        hint = [hint[1],hint[2],hint[0]]
        found = True
      elif mask == 14: # found at vertex v2
        hint = [hint[2],hint[0],hint[1]]
        found = True
      elif mask == 25: # found at edge (v0,v1)
        found = True
      elif mask == 23: # found at edge (v1,v2)
        hint = [hint[1],hint[2],hint[0]]
        found = True
      elif mask == 17: # found at edge (v2,v0)
        hint = [hint[2],hint[0],hint[1]]
        found = True
      elif mask == 26: # found inside face (v0,v1,v2)
        found = True
      else: # 0 | 1 | 3 | 4 | 9 | 10 | 12 | 13: # undefined
        return None

      if hint[2] == 0: # p is outside the convex hull
        break

    return hint

  def __findOthers(self, p, first):
    cavity = [first]
    horizon = []
    Q = Queue(maxsize = 0) # do we need an infinite size queue?
    Q.put(first)

    print("VERTICES SIZE: ", len(self.__tds._vertices))

    visited = numpy.full(len(self.__tds._vertices), False)
    
    while not Q.empty():
      face = Q.get()
      print("  >> popped face: %d %d %d" % (face[0], face[1], face[2]))
      # check each neighbor face for conflict
      for i in range(3):
        v0 = face[(i+1)%3]
        v1 = face[i]
        #v0 = self.__tds._vertices[]
        #v1 = self.__tds._vertices[]
        N = self.__tds.findUp(v0, v1) # neighbor face

        print("    >>> has neighbor: %d %d %d" % (N[0], N[1], N[2]))

        # if visited, skip
        if visited[N[0]] and visited[N[1]] and visited[N[2]]:
          continue

        inConflict = self.__inConflict(p, N[0], N[1], N[2])

        if inConflict:
          print("      >>>> neighbor IN CONFLICT")
          cavity.append(N)
          Q.put(N)
        else: # we've reached the boundary of the cavity
          horizon.append([v1, v0])
          print("      >>>> boundary reached")

      # mark vertices as visited
      #visited[face[:]] = True
      print("BEFORE: ", visited)
      visited[numpy.array(face)] = True
      print("AFTER: ", visited)
    
    return cavity, horizon

  def __find_conflict_set(self, p, hint):
    first  = self.__findFirst(p, hint)
    print("    > first conflict", first)
    cavity, horizon = self.__findOthers(p, first)
    return cavity, horizon
  
  def __remove_conflict(self, conflict):
    print("  >> removing cavity...")

    print("    | BEFORE")
    self.__tds.print()
    # remove faces from cavity
    for face in conflict:
      v0 = face[0]
      v1 = face[1]
      v2 = face[2]
      self.__tds.deleteFace(v0, v1, v2)
    
    print("    | AFTER ")
    self.__tds.print()

  def __fill_cavity(self, p, cavity):
    self.__tds.addVertex()
    v0 = len(self.__tds._vertices) - 1
    print("  >> filling cavity: added vertex %d" % v0)
    for edge in cavity:
      v1 = edge[0]
      v2 = edge[1]
      print("    | adding face %d %d %d" % (v0, v1, v2))
      self.__tds.addFace(v0, v1, v2)
    
    self.__tds._vertices[v0].setPoint(p)

  def __allInfinite(self, faces):
    n = 0
    for f in faces:
      if self.__tds.isInfinite(f[0], f[1], f[2]):
        n = n + 1

    return n == len(faces)

  # Bowyer-Watson algoritm con BRIO
  def insert(self, points):
    assert len(points) >= 3

    brio = Brio()
    points = brio(points)

    self.__insert_first_three(points)
    print('BOOT DONE')
    self.__tds.print()

    hint = 0 # infinite vertex
    for p in points[3:]:
      print("  > Inserting point: ", p.coords)
      
      conflict, cavity = self.__find_conflict_set(p, hint)
      print("  > conflict set: ", conflict)
      print("  > cavity: ", cavity)

      print("  > updating cavity...")
      self.__remove_conflict(conflict)
      self.__fill_cavity(p, cavity)

    print('INSERTION DONE')
    self.__tds.print()

  def debug(self, points):
    assert len(points) >= 3

    self.getBounds(points)
    self.enlargeBounds()

    brio = Brio()
    points = brio(points)
    self.__insert_first_three(points)
    print('BOOT DONE')
    self.__tds.print()
    self.draw()
    self.__fig.canvas.draw_idle() # needed to redraw figure
    plt.gca().set_aspect('equal')
    plt.draw()
    plt.waitforbuttonpress(0) # this will wait for indefinite time

    hint = 0 # infinite vertex
    for p in points[3:]:
      print("  > Inserindo ponto: ", p.coords)
      drawPoint(self.__fig, p)
      self.__fig.canvas.draw_idle() # needed to redraw figure
      plt.gca().set_aspect('equal')
      plt.draw()
      plt.waitforbuttonpress(0) # this will wait for indefinite time
      
      conflict, cavity = self.__find_conflict_set(p, hint)
      print("  > conflict: ", conflict)
      print("  > cavity: ", cavity)
      print("  > updating cavity...")
      self.drawCavity(conflict)
      self.drawHorizon(cavity)
      self.drawCircumcircles(conflict)
      self.__fig.canvas.draw_idle() # needed to redraw figure
      plt.gca().set_aspect('equal')
      plt.draw()
      plt.waitforbuttonpress(0) # this will wait for indefinite time

      self.__remove_conflict(conflict)
      if not self.__allInfinite(conflict):
        plt.clf()
        drawPoint(self.__fig, p)
        self.drawCavity(conflict)
        self.drawHorizon(cavity)
        self.draw()
        self.__fig.canvas.draw_idle() # needed to redraw figure
        plt.gca().set_aspect('equal')
        plt.draw()
        plt.waitforbuttonpress(0) # this will wait for indefinite time

      self.__fill_cavity(p, cavity)
      print("AFTER CAVITY UPDATE:")

      plt.clf()
      self.draw()
      self.__fig.canvas.draw_idle() # needed to redraw figure
      plt.gca().set_aspect('equal')
      plt.draw()
      plt.waitforbuttonpress(0) # this will wait for indefinite time


    print('INSERTION DONE')
    self.__tds.print()

  def setBounds(self, pmin, pmax):
    self.__min = pmin
    self.__max = pmax
  
  def getBounds(self, points):
    for p in points:
      xmin = min(p.x, self.__min.x)
      ymin = min(p.y, self.__min.y)

      xmax = max(p.x, self.__max.x)
      ymax = max(p.y, self.__max.y)

      self.setBounds(Point(xmin, ymin), Point(xmax, ymax))

  def enlargeBounds(self):
    xmin = self.__min.x
    ymin = self.__min.y
    xmax = self.__max.x
    ymax = self.__max.y

    dx = xmax - xmin
    dy = ymax - ymin

    cx = xmin + dx/2
    cy = ymin + dy/2

    xmin = 1.1*(xmin - cx) + cx
    ymin = 1.1*(ymin - cy) + cy
    xmax = 1.1*(xmax - cx) + cx
    ymax = 1.1*(ymax - cy) + cy

    self.setBounds(Point(xmin, ymin), Point(xmax, ymax))

  def drawLabels(self):
    plt.figure(self.__fig)
    for i, v in enumerate(self.__tds._vertices):
      p = v.point
      plt.annotate(r"$v_{0}$".format(i), xy=p.coords)

  def drawCavity(self, cavity):
    plt.figure(self.__fig)
    plt.xlim(self.__min.x, self.__max.x)
    plt.ylim(self.__min.y, self.__max.y)

    for face in cavity:
      iv0 = face[0]
      iv1 = face[1]
      iv2 = face[2]
      if not self.__tds.isInfinite(iv0, iv1, iv2):
        v0 = self.__tds._vertices[iv0]
        v1 = self.__tds._vertices[iv1]
        v2 = self.__tds._vertices[iv2]
        drawTriangle(self.__fig, v0.point, v1.point, v2.point, filled=True)

  def drawCircumcircles(self, cavity):
    plt.figure(self.__fig)
    plt.xlim(self.__min.x, self.__max.x)
    plt.ylim(self.__min.y, self.__max.y)

    patches = []
    for face in cavity:
      iv0 = face[0]
      iv1 = face[1]
      iv2 = face[2]
      if not self.__tds.isInfinite(iv0, iv1, iv2):
        v0 = self.__tds._vertices[iv0]
        v1 = self.__tds._vertices[iv1]
        v2 = self.__tds._vertices[iv2]

        c,r = circumcircle(v0.point, v1.point, v2.point)
        print("Circumcircle: c = (%f, %f), r = %f" % (c.x, c.y, r))
        circle = Circle(c.coords, radius=r)
        patches.append(circle)

    collection = PatchCollection(patches, edgecolor='magenta', facecolor='none', linewidth=2)
    ax = plt.gca()
    ax.add_collection(collection)

  def drawHorizon(self, horizon):
    plt.figure(self.__fig)
    plt.xlim(self.__min.x, self.__max.x)
    plt.ylim(self.__min.y, self.__max.y)

    for edge in horizon:
      iv0 = edge[0]
      iv1 = edge[1]
      if not self.__tds.isInfinite(iv0, iv1):
        v0 = self.__tds._vertices[iv0]
        v1 = self.__tds._vertices[iv1]
        drawSegment(self.__fig, v0.point, v1.point)

  def draw(self):
    plt.figure(self.__fig)
    plt.xlim(self.__min.x, self.__max.x)
    plt.ylim(self.__min.y, self.__max.y)

    for iv0 in range(1, len(self.__tds._vertices)): # skip infinite vertex
      v0 = self.__tds._vertices[iv0]
      for path in v0._links:
        for j in range(len(path)-1):
          iv1 = path[j]
          iv2 = path[j+1]
          if not self.__tds.isInfinite(iv0, iv1, iv2):
            print("drawing face: %d %d %d" % (iv0, iv1, iv2))
            v1 = self.__tds._vertices[iv1]
            v2 = self.__tds._vertices[iv2]
            drawTriangle(self.__fig, v0.point, v1.point, v2.point, filled=False)
    self.drawLabels()
