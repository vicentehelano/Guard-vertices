# -*- coding: utf-8 -*-
"""
Automatically generated by Colab.
"""

import numpy
import copy

# Shewchuck geometric predicates
import geompreds as gp

# Comparison result
SMALLER = -1
EQUAL   = +0
LARGER  = +1

class Point: # here
  def __init__(self, x, y):
    self._x = x
    self._y = y

  @property
  def x(self):
    return self._x

  @property
  def y(self):
    return self._y

  @property
  def coords(self):
    return (self._x, self._y)

  def setX(self, x):
    self._x = x

  def setY(self, y):
    self._y = y

def determinant(a00, a01, a10, a11):
  return a00*a11 - a10*a01

def __circumcircle(p, q, r):
  print("    >> circumcircle for points:")
  print("       | p: (%f, %f)" % (p.x, p.y))
  print("       | q: (%f, %f)" % (q.x, q.y))
  print("       | r: (%f, %f)" % (r.x, r.y))
  # compute circumcenter
  x_rp = p.x - r.x
  y_rp = p.y - r.y
  x_rq = q.x - r.x
  y_rq = q.y - r.y
  x_pq = q.x - p.x
  y_pq = q.y - p.y

  d_rp = x_rp*x_rp + y_rp*y_rp
  d_rq = x_rq*x_rq + y_rq*y_rq
  d_pq = x_pq*x_pq + y_pq*y_pq

  numx = determinant(d_rp, y_rp, d_rq, y_rq)
  numy = determinant(x_rp, d_rp, x_rq, d_rq)

  den = 0.5 / determinant(x_rp, y_rp, x_rq, y_rq)

  c_x = r.x + numx * den
  c_y = r.y + numy * den

  numr = numpy.sqrt( d_rp * d_rq * d_pq )
  r = numr * den

  return Point(c_x, c_y), r

# Source: Shewchuk notes on Robust Geometric Predicates
# https://people.eecs.berkeley.edu/~jrs/meshpapers/robnotes.pdf
def circumcircle(p, q, r):
  orient = orientation(p, q, r)
  assert orient != 0 # COLLINEAR
  print("    >> computing circumcircle")
  return __circumcircle(p, q, r)

def orientation(p0: Point, p1: Point, p2: Point, p3 = None):
  if p3 is None:
    return numpy.sign(gp.orient2d(p0.coords, p1.coords, p2.coords))
  else:
    return numpy.sign(gp.incircle(p0.coords, p1.coords, p2.coords, p3.coords))
  
# idea borrowed from CGAL
def __compare(a, b):
  if (a < b):
    return SMALLER
  if (a > b):
    return LARGER
  return EQUAL

# Source: adapted from CGAL's compare_{x,y}
# return true if point r is strictly between p and q
# p, q and r are supposed to be collinear points
def inBetween(p, q, r):
  c_pq = __compare(p.x, q.x)
  c_pr = None
  c_rq = None
  if (c_pq == EQUAL):
    c_pr = __compare(p.y, r.y)
    c_rq = __compare(r.y, q.y)
  else:
    c_pr = __compare(p.x, r.x)
    c_rq = __compare(r.x, q.x)

  return ( (c_pr == SMALLER) and (c_rq == SMALLER) ) or ( (c_pr == LARGER)  and (c_rq == LARGER) )