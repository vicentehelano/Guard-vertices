# -*- coding: utf-8 -*-
"""
Automatically generated by Colab.
"""

# Import standard packages
import numpy

# Import from local packages
from .utils import Point

class Vertex: # here
  def __init__(self, point=None):
    self._links = []
    self._point = point

  def setPoint(self, point):
    self._point = point

  @property
  def point(self):
    return self._point

class StarVertices:
  """
  This is an object oriented implementation of Blandford's simplicial
  complex data structure.
  """
  def __init__(self):
    self._vertices = []
    self.addVertex( Vertex( Point(numpy.inf,numpy.inf) ) ) # infinite vertex, index 0

  def addVertex(self, v=None):
    if v is None:
      v = Vertex()
    self._vertices.append(v)

  # A triangle t can be added by finding the representative
  # vertices of t and extending each of their link sets.
  # This extension might:
  #     (i) add a new path to the set, if neither of the two
  #         vertices are in the set;
  #    (ii) extend an existing path, if one vertex is in the set;
  #   (iii) join two existing paths, if the two vertices are in
  #         separate paths;
  #    (iv) join a path into a cycle, if the two vertices are the
  #         ends of the same path.
  def __addFace(self, v0, v1, v2):
    i1 = i2 = p1 = p2 = None
    links = self._vertices[v0]._links
    print("      | adding face to vertex %d" % v0)
    print("      |                link before: ", links)
    # get the path of each neighbor, and its respective index
    for index, path in enumerate(links):
      if v1 in path:
        i1 = path.index(v1)
        p1 = index
      if v2 in path:
        i2 = path.index(v2)
        p2 = index

    if p1 is None and p2 is None: # case (i)
      links.append([v1,v2])
    elif p1 is not None and p2 is None: # case (ii-a)
      links[p1].insert(i1+1,v2)
    elif p1 is None and p2 is not None: # case (ii-b)
      links[p2].insert(i2,v1)
    else: # join paths
      if p1 != p2: # case (iii)
        pmin = pmax = pos = None
        if p1 < p2:
          pmin, pmax = p1, p2
          pos = i1 + 1
        else:
          pmin, pmax = p2, p1
          pos = i2
        links[pmin][pos:pos] = links[pmax]
        del links[pmax]
      else: # case (iv)
        # we can only join extreme neighbors
        assert i2 == 0 and (i1+1) == len(links[p1])
        links[p1].append(v2)
    print("      |                link after: ", links)

  def addFace(self, v0, v1, v2):
    self.__addFace(v0, v1, v2)
    self.__addFace(v1, v2, v0)
    self.__addFace(v2, v0, v1)

  # A triange t can be deleted by finding the representative
  # vertices of t and splitting a cycle or a path of each of
  # their links.
  def __deleteFace(self, v0, v1, v2):
    #i1 = None
    i2 = p1 = p2 = None
    links = self._vertices[v0]._links
    for index, path in enumerate(links):
      if v1 in path:
        #i1 = path.index(v1)
        p1 = index
      if v2 in path:
        i2 = path.index(v2)
        p2 = index

    ####
    # TODO: FIX REMOVING Of Non-existent faces
    ####

    # both neighbors must be in the same path
    assert p1 == p2

    begin  = links[p1][0]
    end    = links[p1][-1]

    first  = links[p1][:i2]
    latest = links[p1][i2:]

    del links[p1]

    assert (len(first) + len(latest)) > 1

    if begin == end: # closed links remain connected
      links.append(latest[:-1] + first)
    else: # open paths are just split
      if len(first) > 1:
        links.insert(p1,first)
      if len(latest) > 1:
        links.insert(p1+1,latest)

  def deleteFace(self, v0, v1, v2):
    self.__deleteFace(v0, v1, v2)
    self.__deleteFace(v1, v2, v0)
    self.__deleteFace(v2, v0, v1)

  # findUp sempre retorna o triângulo que contém
  # o simplexo dado.
  def findUp(self, v0, v1=None):
    if v0 is not None:
      if v1 is not None: # return oriented face (v0,v1,v2)
        i1 = p1 = None
        links = self._vertices[v0]._links
        # get the path and index of v1
        for index, path in enumerate(links):
          if v1 in path:
            i1 = path.index(v1)
            p1 = index

        link = self._vertices[v0]._links[p1]
        last = len(link) - 1
        if i1 == last: # open link, because 'index()' always return first occurrence
          return None  # so, there is no 'v2' such that (v0,v1,v2) is a face

        v2 = link[i1+1]
        return v0, v1, v2
      else: # return any edge (v0,v1)
        pass
    else: # error
      return None
    
  def isInfinite(self, v0, v1 = None, v2 = None):
    if v2 is None:
      if v1 is None:
        return v0 == 0
      else:
        return  (v0 == 0) or (v1 == 0)
    else:
      return  (v0 == 0) or (v1 == 0) or (v2 == 0)

  def print(self):      
    print('> links:')
    for i in range(len(self._vertices)):
      print(self._vertices[i]._links)